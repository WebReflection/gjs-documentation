<?xml version="1.0"?>
<page id="GLib.HashFunc"
      type="topic"
      style="callback"
      xmlns="http://projectmallard.org/1.0/"
      xmlns:api="http://projectmallard.org/experimental/api/"
      xmlns:ui="http://projectmallard.org/1.0/ui/">
  <info>
    <link xref="index" group="callback" type="guide"/>
  </info>
  <title>GLib.HashFunc</title>
  <synopsis><code mime="text/x-gjs">
function onHashFunc(key: gpointer): Number {
}
  </code></synopsis>
  <p>Specifies the type of the hash function which is passed to
<link xref="GLib.new"/> when a <link xref="GLib.HashTable"/> is created.</p>  <p>The function is passed a key and should return a #guint hash value.
The functions <link xref="GLib.direct_hash"/>, <link xref="GLib.int_hash"/> and <link xref="GLib.str_hash"/> provide
hash functions which can be used when the key is a #gpointer, #gint*,
and #gchar* respectively.</p>  <p><link xref="GLib.direct_hash"/> is also the appropriate hash function for keys
of the form `GINT_TO_POINTER (n)` (or similar macros).</p>  <p>&lt;!-- FIXME: Need more here. --&gt; A good hash functions should produce
hash values that are evenly distributed over a fairly large range.
The modulus is taken with the hash table size (a prime number) to
find the 'bucket' to place each key into. The function should also
be very fast, since it is called for each key lookup.</p>  <p>Note that the hash functions provided by GLib have these qualities,
but are not particularly robust against manufactured keys that
cause hash collisions. Therefore, you should consider choosing
a more secure hash function when using a GHashTable with keys
that originate in untrusted data (such as HTTP requests).
Using <link xref="GLib.str_hash"/> in that situation might make your application
vulerable to
[Algorithmic Complexity Attacks](https://lwn.net/Articles/474912/).</p>  <p>The key to choosing a good hash is unpredictability.  Even
cryptographic hashes are very easy to find collisions for when the
remainder is taken modulo a somewhat predictable prime number.  There
must be an element of randomness that an attacker is unable to guess.</p>

<terms>
<item>
<title><code>key</code></title>
  <p>a key</p>
</item>
<item>
<title><code>Returns</code></title>

</item>
</terms>

</page>
