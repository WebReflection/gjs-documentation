<?xml version="1.0"?>
<page id="GLib.Cond.wait_until"
      type="topic"
      style="method"
      xmlns="http://projectmallard.org/1.0/"
      xmlns:api="http://projectmallard.org/experimental/api/"
      xmlns:ui="http://projectmallard.org/1.0/ui/">
  <info>
    <link xref="GLib.Cond" group="method" type="guide"/>
    <api:function>
      <api:returns>
        <api:type>Boolean</api:type>
      </api:returns>
      <api:name>g_cond_wait_until</api:name>
      <api:arg>
        <api:type>GLib.Mutex</api:type>
        <api:name>mutex</api:name>
      </api:arg>
      <api:arg>
        <api:type>Number(gint64)</api:type>
        <api:name>end_time</api:name>
      </api:arg>
    </api:function>
  </info>
  <title>GLib.Cond.prototype.wait_until</title>
  <synopsis><code mime="text/x-gjs">
function wait_until(mutex: <link xref="GLib.Mutex">GLib.Mutex</link>, end_time: Number(gint64)): Boolean {
    // Gjs wrapper for g_cond_wait_until()
}
  </code></synopsis>
  <p>Waits until either <code>cond</code> is signalled or <code>end_time</code> has passed.</p>  <p>As with <link xref="GLib.Cond.wait"/> it is possible that a spurious or stolen wakeup
could occur.  For that reason, waiting on a condition variable should
always be in a loop, based on an explicitly-checked predicate.</p>  <p><code>true</code> is returned if the condition variable was signalled (or in the
case of a spurious wakeup).  <code>false</code> is returned if <code>end_time</code> has
passed.</p>  <p>The following code shows how to correctly perform a timed wait on a
condition variable (extending the example presented in the
documentation for <link xref="GLib.Cond"/>):</p>  <p>|[&lt;!-- language="C" --&gt;
gpointer
pop_data_timed (void)
{
  gint64 end_time;
  gpointer data;</p>  <p>  g_mutex_lock (&amp;data_mutex);</p>  <p>  end_time = g_get_monotonic_time () + 5 * G_TIME_SPAN_SECOND;
  while (!current_data)
    if (!g_cond_wait_until (&amp;data_cond, &amp;data_mutex, end_time))
      {
        // timeout has passed.
        g_mutex_unlock (&amp;data_mutex);
        return NULL;
      }</p>  <p>  // there is data for us
  data = current_data;
  current_data = NULL;</p>  <p>  g_mutex_unlock (&amp;data_mutex);</p>  <p>  return data;
}
]|</p>  <p>Notice that the end time is calculated once, before entering the
loop and reused.  This is the motivation behind the use of absolute
time on this API -- if a relative time of 5 seconds were passed
directly to the call and a spurious wakeup occurred, the program would
have to start over waiting again (which would lead to a total wait
time of more than 5 seconds).</p>
  <p>Since 2.32</p>
<terms>
<item>
<title><code>mutex</code></title>
  <p>a <link xref="GLib.Mutex"/> that is currently locked</p>
</item>
<item>
<title><code>end_time</code></title>
  <p>the monotonic time to wait until</p>
</item>
<item>
<title><code>ok</code></title>

</item>
</terms>

</page>
