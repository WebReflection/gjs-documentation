<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>Gio.Task</title>
<link rel="stylesheet" type="text/css" href="C.css">
<script type="text/javascript" src="jquery.js"></script><script type="text/javascript" src="jquery.syntax.js"></script><script type="text/javascript" src="yelp.js"></script>
</head>
<body><div class="page" role="main">
<div class="header"><div class="trails" role="navigation"><div class="trail">
<a class="trail" href="index.html" title="Gio">Gio</a> » </div></div></div>
<div class="body">
<div class="hgroup"><h1 class="title"><span class="title">Gio.Task</span></h1></div>
<div class="region">
<div class="contents">
<div class="synopsis"><div class="inner"><div class="region"><div class="contents"><div class="code"><pre class="contents ">const Gio = imports.gi.Gio;

let task = new Gio.Task();
  </pre></div></div></div></div></div>
<p class="p">A <span class="link"><a href="Gio.Task.html" title="Gio.Task">Gio.Task</a></span> represents and manages a cancellable "task".</p>
<p class="p">## Asynchronous operations</p>
<p class="p">The most common usage of <span class="link"><a href="Gio.Task.html" title="Gio.Task">Gio.Task</a></span> is as a <span class="link"><a href="Gio.AsyncResult.html" title="Gio.AsyncResult">Gio.AsyncResult</a></span>, to
manage data during an asynchronous operation. You call
<span class="link"><a href="Gio.Task.new.html" title="Gio.Task.new">Gio.Task.new</a></span> in the "start" method, followed by
<span class="link"><a href="Gio.Task.set_task_data.html" title="Gio.Task.prototype.set_task_data">Gio.Task.prototype.set_task_data</a></span> and the like if you need to keep some
additional data associated with the task, and then pass the
task object around through your asynchronous operation.
Eventually, you will call a method such as
<span class="link"><a href="Gio.Task.return_pointer.html" title="Gio.Task.prototype.return_pointer">Gio.Task.prototype.return_pointer</a></span> or <span class="link"><a href="Gio.Task.return_error.html" title="Gio.Task.prototype.return_error">Gio.Task.prototype.return_error</a></span>, which will
save the value you give it and then invoke the task's callback
function (waiting until the next iteration of the main
loop first, if necessary). The caller will pass the <span class="link"><a href="Gio.Task.html" title="Gio.Task">Gio.Task</a></span> back
to the operation's finish function (as a <span class="link"><a href="Gio.AsyncResult.html" title="Gio.AsyncResult">Gio.AsyncResult</a></span>), and
you can use <span class="link"><a href="Gio.Task.propagate_pointer.html" title="Gio.Task.prototype.propagate_pointer">Gio.Task.prototype.propagate_pointer</a></span> or the like to extract
the return value.</p>
<p class="p">Here is an example for using GTask as a GAsyncResult:
|[&lt;!-- language="C" --&gt;
    typedef struct {
      CakeFrostingType frosting;
      char *message;
    } DecorationData;</p>
<p class="p">    static void
    decoration_data_free (DecorationData *decoration)
    {
      g_free (decoration-&gt;message);
      g_slice_free (DecorationData, decoration);
    }</p>
<p class="p">    static void
    baked_cb (Cake     *cake,
              gpointer  user_data)
    {
      GTask *task = user_data;
      DecorationData *decoration = g_task_get_task_data (task);
      GError *error = NULL;</p>
<p class="p">      if (cake == NULL)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                                   "Go to the supermarket");
          g_object_unref (task);
          return;
        }</p>
<p class="p">      if (!cake_decorate (cake, decoration-&gt;frosting, decoration-&gt;message, &amp;error))
        {
          g_object_unref (cake);
          // <span class="link"><a href="Gio.Task.return_error.html" title="Gio.Task.prototype.return_error">Gio.Task.prototype.return_error</a></span> takes ownership of error
          g_task_return_error (task, error);
          g_object_unref (task);
          return;
        }</p>
<p class="p">      g_task_return_pointer (task, cake, g_object_unref);
      g_object_unref (task);
    }</p>
<p class="p">    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      GTask *task;
      DecorationData *decoration;
      Cake  *cake;</p>
<p class="p">      task = g_task_new (self, cancellable, callback, user_data);
      if (radius &lt; 3)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
                                   "%ucm radius cakes are silly",
                                   radius);
          g_object_unref (task);
          return;
        }</p>
<p class="p">      cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
      if (cake != NULL)
        {
          // _baker_get_cached_cake() returns a reffed cake
          g_task_return_pointer (task, cake, g_object_unref);
          g_object_unref (task);
          return;
        }</p>
<p class="p">      decoration = g_slice_new (DecorationData);
      decoration-&gt;frosting = frosting;
      decoration-&gt;message = g_strdup (message);
      g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);</p>
<p class="p">      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
    }</p>
<p class="p">    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);</p>
<p class="p">      return g_task_propagate_pointer (G_TASK (result), error);
    }
]|</p>
<p class="p">## Chained asynchronous operations</p>
<p class="p"><span class="link"><a href="Gio.Task.html" title="Gio.Task">Gio.Task</a></span> also tries to simplify asynchronous operations that
internally chain together several smaller asynchronous
operations. <span class="link"><a href="Gio.Task.get_cancellable.html" title="Gio.Task.prototype.get_cancellable">Gio.Task.prototype.get_cancellable</a></span>, <span class="link"><a href="Gio.Task.get_context.html" title="Gio.Task.prototype.get_context">Gio.Task.prototype.get_context</a></span>,
and <span class="link"><a href="Gio.Task.get_priority.html" title="Gio.Task.prototype.get_priority">Gio.Task.prototype.get_priority</a></span> allow you to get back the task's
<span class="link"><a href="Gio.Cancellable.html" title="Gio.Cancellable">Gio.Cancellable</a></span>, <span class="link"><a href="../GLib-2.0/GLib.MainContext.html" title="../GLib-2.0/GLib.MainContext.html">GLib.MainContext</a></span>, and [I/O priority][io-priority]
when starting a new subtask, so you don't have to keep track
of them yourself. <span class="link"><a href="Gio.Task.attach_source.html" title="Gio.Task.attach_source">Gio.Task.attach_source</a></span> simplifies the case
of waiting for a source to fire (automatically using the correct
<span class="link"><a href="../GLib-2.0/GLib.MainContext.html" title="../GLib-2.0/GLib.MainContext.html">GLib.MainContext</a></span> and priority).</p>
<p class="p">Here is an example for chained asynchronous operations:
  |[&lt;!-- language="C" --&gt;
    typedef struct {
      Cake *cake;
      CakeFrostingType frosting;
      char *message;
    } BakingData;</p>
<p class="p">    static void
    decoration_data_free (BakingData *bd)
    {
      if (bd-&gt;cake)
        g_object_unref (bd-&gt;cake);
      g_free (bd-&gt;message);
      g_slice_free (BakingData, bd);
    }</p>
<p class="p">    static void
    decorated_cb (Cake         *cake,
                  GAsyncResult *result,
                  gpointer      user_data)
    {
      GTask *task = user_data;
      GError *error = NULL;</p>
<p class="p">      if (!cake_decorate_finish (cake, result, &amp;error))
        {
          g_object_unref (cake);
          g_task_return_error (task, error);
          g_object_unref (task);
          return;
        }</p>
<p class="p">      // baking_data_free() will drop its ref on the cake, so we have to
      // take another here to give to the caller.
      g_task_return_pointer (result, g_object_ref (cake), g_object_unref);
      g_object_unref (task);
    }</p>
<p class="p">    static void
    decorator_ready (gpointer user_data)
    {
      GTask *task = user_data;
      BakingData *bd = g_task_get_task_data (task);</p>
<p class="p">      cake_decorate_async (bd-&gt;cake, bd-&gt;frosting, bd-&gt;message,
                           g_task_get_cancellable (task),
                           decorated_cb, task);
    }</p>
<p class="p">    static void
    baked_cb (Cake     *cake,
              gpointer  user_data)
    {
      GTask *task = user_data;
      BakingData *bd = g_task_get_task_data (task);
      GError *error = NULL;</p>
<p class="p">      if (cake == NULL)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                                   "Go to the supermarket");
          g_object_unref (task);
          return;
        }</p>
<p class="p">      bd-&gt;cake = cake;</p>
<p class="p">      // Bail out now if the user has already cancelled
      if (g_task_return_error_if_cancelled (task))
        {
          g_object_unref (task);
          return;
        }</p>
<p class="p">      if (cake_decorator_available (cake))
        decorator_ready (task);
      else
        {
          GSource *source;</p>
<p class="p">          source = cake_decorator_wait_source_new (cake);
          // Attach @source to @task's GMainContext and have it call
          // decorator_ready() when it is ready.
          g_task_attach_source (task, source,
                                G_CALLBACK (decorator_ready));
          g_source_unref (source);
        }
    }</p>
<p class="p">    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           gint                 priority,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      GTask *task;
      BakingData *bd;</p>
<p class="p">      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_priority (task, priority);</p>
<p class="p">      bd = g_slice_new0 (BakingData);
      bd-&gt;frosting = frosting;
      bd-&gt;message = g_strdup (message);
      g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);</p>
<p class="p">      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
    }</p>
<p class="p">    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);</p>
<p class="p">      return g_task_propagate_pointer (G_TASK (result), error);
    }
]|</p>
<p class="p">## Asynchronous operations from synchronous ones</p>
<p class="p">You can use <span class="link"><a href="Gio.Task.run_in_thread.html" title="Gio.Task.run_in_thread">Gio.Task.run_in_thread</a></span> to turn a synchronous
operation into an asynchronous one, by running it in a thread
which will then dispatch the result back to the caller's
<span class="link"><a href="../GLib-2.0/GLib.MainContext.html" title="../GLib-2.0/GLib.MainContext.html">GLib.MainContext</a></span> when it completes.</p>
<p class="p">Running a task in a thread:
  |[&lt;!-- language="C" --&gt;
    typedef struct {
      guint radius;
      CakeFlavor flavor;
      CakeFrostingType frosting;
      char *message;
    } CakeData;</p>
<p class="p">    static void
    cake_data_free (CakeData *cake_data)
    {
      g_free (cake_data-&gt;message);
      g_slice_free (CakeData, cake_data);
    }</p>
<p class="p">    static void
    bake_cake_thread (GTask         *task,
                      gpointer       source_object,
                      gpointer       task_data,
                      GCancellable  *cancellable)
    {
      Baker *self = source_object;
      CakeData *cake_data = task_data;
      Cake *cake;
      GError *error = NULL;</p>
<p class="p">      cake = bake_cake (baker, cake_data-&gt;radius, cake_data-&gt;flavor,
                        cake_data-&gt;frosting, cake_data-&gt;message,
                        cancellable, &amp;error);
      if (cake)
        g_task_return_pointer (task, cake, g_object_unref);
      else
        g_task_return_error (task, error);
    }</p>
<p class="p">    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      CakeData *cake_data;
      GTask *task;</p>
<p class="p">      cake_data = g_slice_new (CakeData);
      cake_data-&gt;radius = radius;
      cake_data-&gt;flavor = flavor;
      cake_data-&gt;frosting = frosting;
      cake_data-&gt;message = g_strdup (message);
      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_run_in_thread (task, bake_cake_thread);
    }</p>
<p class="p">    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);</p>
<p class="p">      return g_task_propagate_pointer (G_TASK (result), error);
    }
]|</p>
<p class="p">## Adding cancellability to uncancellable tasks</p>
<p class="p">Finally, <span class="link"><a href="Gio.Task.run_in_thread.html" title="Gio.Task.run_in_thread">Gio.Task.run_in_thread</a></span> and <span class="link"><a href="Gio.Task.run_in_thread_sync.html" title="Gio.Task.run_in_thread_sync">Gio.Task.run_in_thread_sync</a></span>
can be used to turn an uncancellable operation into a
cancellable one. If you call <span class="link"><a href="Gio.Task.set_return_on_cancel.html" title="Gio.Task.prototype.set_return_on_cancel">Gio.Task.prototype.set_return_on_cancel</a></span>,
passing <span class="code">true</span>, then if the task's <span class="link"><a href="Gio.Cancellable.html" title="Gio.Cancellable">Gio.Cancellable</a></span> is cancelled,
it will return control back to the caller immediately, while
allowing the task thread to continue running in the background
(and simply discarding its result when it finally does finish).
Provided that the task thread is careful about how it uses
locks and other externally-visible resources, this allows you
to make "GLib-friendly" asynchronous and cancellable
synchronous variants of blocking APIs.</p>
<p class="p">Cancelling a task:
  |[&lt;!-- language="C" --&gt;
    static void
    bake_cake_thread (GTask         *task,
                      gpointer       source_object,
                      gpointer       task_data,
                      GCancellable  *cancellable)
    {
      Baker *self = source_object;
      CakeData *cake_data = task_data;
      Cake *cake;
      GError *error = NULL;</p>
<p class="p">      cake = bake_cake (baker, cake_data-&gt;radius, cake_data-&gt;flavor,
                        cake_data-&gt;frosting, cake_data-&gt;message,
                        &amp;error);
      if (error)
        {
          g_task_return_error (task, error);
          return;
        }</p>
<p class="p">      // If the task has already been cancelled, then we don't want to add
      // the cake to the cake cache. Likewise, we don't  want to have the
      // task get cancelled in the middle of updating the cache.
      // <span class="link"><a href="Gio.Task.set_return_on_cancel.html" title="Gio.Task.prototype.set_return_on_cancel">Gio.Task.prototype.set_return_on_cancel</a></span> will return <span class="code">true</span> here if it managed
      // to disable return-on-cancel, or <span class="code">false</span> if the task was cancelled
      // before it could.
      if (g_task_set_return_on_cancel (task, FALSE))
        {
          // If the caller cancels at this point, their
          // GAsyncReadyCallback won't be invoked until we return,
          // so we don't have to worry that this code will run at
          // the same time as that code does. But if there were
          // other functions that might look at the cake cache,
          // then we'd probably need a GMutex here as well.
          baker_add_cake_to_cache (baker, cake);
          g_task_return_pointer (task, cake, g_object_unref);
        }
    }</p>
<p class="p">    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      CakeData *cake_data;
      GTask *task;</p>
<p class="p">      cake_data = g_slice_new (CakeData);</p>
<p class="p">      ...</p>
<p class="p">      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_set_return_on_cancel (task, TRUE);
      g_task_run_in_thread (task, bake_cake_thread);
    }</p>
<p class="p">    Cake *
    baker_bake_cake_sync (Baker               *self,
                          guint                radius,
                          CakeFlavor           flavor,
                          CakeFrostingType     frosting,
                          const char          *message,
                          GCancellable        *cancellable,
                          GError             **error)
    {
      CakeData *cake_data;
      GTask *task;
      Cake *cake;</p>
<p class="p">      cake_data = g_slice_new (CakeData);</p>
<p class="p">      ...</p>
<p class="p">      task = g_task_new (self, cancellable, NULL, NULL);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_set_return_on_cancel (task, TRUE);
      g_task_run_in_thread_sync (task, bake_cake_thread);</p>
<p class="p">      cake = g_task_propagate_pointer (task, error);
      g_object_unref (task);
      return cake;
    }
]|</p>
<p class="p">## Porting from GSimpleAsyncResult</p>
<p class="p"><span class="link"><a href="Gio.Task.html" title="Gio.Task">Gio.Task</a></span>'s API attempts to be simpler than <span class="link"><a href="Gio.SimpleAsyncResult.html" title="Gio.SimpleAsyncResult">Gio.SimpleAsyncResult</a></span>'s
in several ways:
- You can save task-specific data with <span class="link"><a href="Gio.Task.set_task_data.html" title="Gio.Task.prototype.set_task_data">Gio.Task.prototype.set_task_data</a></span>, and
  retrieve it later with <span class="link"><a href="Gio.Task.get_task_data.html" title="Gio.Task.prototype.get_task_data">Gio.Task.prototype.get_task_data</a></span>. This replaces the
  abuse of <span class="link"><a href="Gio.SimpleAsyncResult.set_op_res_gpointer.html" title="Gio.SimpleAsyncResult.set_op_res_gpointer">Gio.SimpleAsyncResult.set_op_res_gpointer</a></span> for the same
  purpose with <span class="link"><a href="Gio.SimpleAsyncResult.html" title="Gio.SimpleAsyncResult">Gio.SimpleAsyncResult</a></span>.
- In addition to the task data, <span class="link"><a href="Gio.Task.html" title="Gio.Task">Gio.Task</a></span> also keeps track of the
  [priority][io-priority], <span class="link"><a href="Gio.Cancellable.html" title="Gio.Cancellable">Gio.Cancellable</a></span>, and
  <span class="link"><a href="../GLib-2.0/GLib.MainContext.html" title="../GLib-2.0/GLib.MainContext.html">GLib.MainContext</a></span> associated with the task, so tasks that consist of
  a chain of simpler asynchronous operations will have easy access
  to those values when starting each sub-task.
- <span class="link"><a href="Gio.Task.return_error_if_cancelled.html" title="Gio.Task.prototype.return_error_if_cancelled">Gio.Task.prototype.return_error_if_cancelled</a></span> provides simplified
  handling for cancellation. In addition, cancellation
  overrides any other <span class="link"><a href="Gio.Task.html" title="Gio.Task">Gio.Task</a></span> return value by default, like
  <span class="link"><a href="Gio.SimpleAsyncResult.html" title="Gio.SimpleAsyncResult">Gio.SimpleAsyncResult</a></span> does when
  <span class="link"><a href="Gio.SimpleAsyncResult.set_check_cancellable.html" title="Gio.SimpleAsyncResult.prototype.set_check_cancellable">Gio.SimpleAsyncResult.prototype.set_check_cancellable</a></span> is called.
  (You can use <span class="link"><a href="Gio.Task.set_check_cancellable.html" title="Gio.Task.prototype.set_check_cancellable">Gio.Task.prototype.set_check_cancellable</a></span> to turn off that
  behavior.) On the other hand, <span class="link"><a href="Gio.Task.run_in_thread.html" title="Gio.Task.run_in_thread">Gio.Task.run_in_thread</a></span>
  guarantees that it will always run your
  `task_func`, even if the task's <span class="link"><a href="Gio.Cancellable.html" title="Gio.Cancellable">Gio.Cancellable</a></span>
  is already cancelled before the task gets a chance to run;
  you can start your `task_func` with a
  <span class="link"><a href="Gio.Task.return_error_if_cancelled.html" title="Gio.Task.prototype.return_error_if_cancelled">Gio.Task.prototype.return_error_if_cancelled</a></span> check if you need the
  old behavior.
- The "return" methods (eg, <span class="link"><a href="Gio.Task.return_pointer.html" title="Gio.Task.prototype.return_pointer">Gio.Task.prototype.return_pointer</a></span>)
  automatically cause the task to be "completed" as well, and
  there is no need to worry about the "complete" vs "complete
  in idle" distinction. (<span class="link"><a href="Gio.Task.html" title="Gio.Task">Gio.Task</a></span> automatically figures out
  whether the task's callback can be invoked directly, or
  if it needs to be sent to another <span class="link"><a href="../GLib-2.0/GLib.MainContext.html" title="../GLib-2.0/GLib.MainContext.html">GLib.MainContext</a></span>, or delayed
  until the next iteration of the current <span class="link"><a href="../GLib-2.0/GLib.MainContext.html" title="../GLib-2.0/GLib.MainContext.html">GLib.MainContext</a></span>.)
- The "finish" functions for <span class="link"><a href="Gio.Task.html" title="Gio.Task">Gio.Task</a></span>-based operations are generally
  much simpler than <span class="link"><a href="Gio.SimpleAsyncResult.html" title="Gio.SimpleAsyncResult">Gio.SimpleAsyncResult</a></span> ones, normally consisting
  of only a single call to <span class="link"><a href="Gio.Task.propagate_pointer.html" title="Gio.Task.prototype.propagate_pointer">Gio.Task.prototype.propagate_pointer</a></span> or the like.
  Since <span class="link"><a href="Gio.Task.propagate_pointer.html" title="Gio.Task.prototype.propagate_pointer">Gio.Task.prototype.propagate_pointer</a></span> "steals" the return value from
  the <span class="link"><a href="Gio.Task.html" title="Gio.Task">Gio.Task</a></span>, it is not necessary to juggle pointers around to
  prevent it from being freed twice.
- With <span class="link"><a href="Gio.SimpleAsyncResult.html" title="Gio.SimpleAsyncResult">Gio.SimpleAsyncResult</a></span>, it was common to call
  <span class="link"><a href="Gio.SimpleAsyncResult.propagate_error.html" title="Gio.SimpleAsyncResult.prototype.propagate_error">Gio.SimpleAsyncResult.prototype.propagate_error</a></span> from the
  `_finish()` wrapper function, and have
  virtual method implementations only deal with successful
  returns. This behavior is deprecated, because it makes it
  difficult for a subclass to chain to a parent class's async
  methods. Instead, the wrapper function should just be a
  simple wrapper, and the virtual method should call an
  appropriate `g_task_propagate_` function.
  Note that wrapper methods can now use
  <span class="link"><a href="Gio.AsyncResult.legacy_propagate_error.html" title="Gio.AsyncResult.prototype.legacy_propagate_error">Gio.AsyncResult.prototype.legacy_propagate_error</a></span> to do old-style
  <span class="link"><a href="Gio.SimpleAsyncResult.html" title="Gio.SimpleAsyncResult">Gio.SimpleAsyncResult</a></span> error-returning behavior, and
  <span class="link"><a href="Gio.AsyncResult.is_tagged.html" title="Gio.AsyncResult.prototype.is_tagged">Gio.AsyncResult.prototype.is_tagged</a></span> to check if a result is tagged as
  having come from the `_async()` wrapper
  function (for "short-circuit" results, such as when passing
  0 to <span class="link"><a href="Gio.InputStream.read_async.html" title="Gio.InputStream.prototype.read_async">Gio.InputStream.prototype.read_async</a></span>).</p>
<div class="synopsis"><div class="inner">
<div class="title title-synopsis"><h2><span class="title">Hierarchy</span></h2></div>
<div class="region"><div class="contents"><div class="tree"><div class="inner"><div class="region"><ul class="tree"><li class="tree">
<div>
        <span class="code">GObject.Object</span>
      
      </div>
<ul class="tree"><li class="tree"><div>
        <span class="code">Gio.Task</span>
      </div></li></ul>
</li></ul></div></div></div></div></div>
</div></div>
<div class="links topiclinks"><div class="inner">
<div class="title title-links"><h2><span class="title">Constructors</span></h2></div>
<div class="region"><ul><li class="links "><a href="Gio.Task.new.html" title="Gio.Task.new">Gio.Task.new</a></li></ul></div>
</div></div>
<div class="links topiclinks"><div class="inner">
<div class="title title-links"><h2><span class="title">Methods</span></h2></div>
<div class="region"><ul>
<li class="links "><a href="Gio.Task.get_cancellable.html" title="Gio.Task.prototype.get_cancellable">Gio.Task.prototype.get_cancellable</a></li>
<li class="links "><a href="Gio.Task.get_check_cancellable.html" title="Gio.Task.prototype.get_check_cancellable">Gio.Task.prototype.get_check_cancellable</a></li>
<li class="links "><a href="Gio.Task.get_context.html" title="Gio.Task.prototype.get_context">Gio.Task.prototype.get_context</a></li>
<li class="links "><a href="Gio.Task.get_priority.html" title="Gio.Task.prototype.get_priority">Gio.Task.prototype.get_priority</a></li>
<li class="links "><a href="Gio.Task.get_return_on_cancel.html" title="Gio.Task.prototype.get_return_on_cancel">Gio.Task.prototype.get_return_on_cancel</a></li>
<li class="links "><a href="Gio.Task.get_source_object.html" title="Gio.Task.prototype.get_source_object">Gio.Task.prototype.get_source_object</a></li>
<li class="links "><a href="Gio.Task.get_source_tag.html" title="Gio.Task.prototype.get_source_tag">Gio.Task.prototype.get_source_tag</a></li>
<li class="links "><a href="Gio.Task.get_task_data.html" title="Gio.Task.prototype.get_task_data">Gio.Task.prototype.get_task_data</a></li>
<li class="links "><a href="Gio.Task.had_error.html" title="Gio.Task.prototype.had_error">Gio.Task.prototype.had_error</a></li>
<li class="links "><a href="Gio.Task.propagate_boolean.html" title="Gio.Task.prototype.propagate_boolean">Gio.Task.prototype.propagate_boolean</a></li>
<li class="links "><a href="Gio.Task.propagate_int.html" title="Gio.Task.prototype.propagate_int">Gio.Task.prototype.propagate_int</a></li>
<li class="links "><a href="Gio.Task.propagate_pointer.html" title="Gio.Task.prototype.propagate_pointer">Gio.Task.prototype.propagate_pointer</a></li>
<li class="links "><a href="Gio.Task.return_boolean.html" title="Gio.Task.prototype.return_boolean">Gio.Task.prototype.return_boolean</a></li>
<li class="links "><a href="Gio.Task.return_error.html" title="Gio.Task.prototype.return_error">Gio.Task.prototype.return_error</a></li>
<li class="links "><a href="Gio.Task.return_error_if_cancelled.html" title="Gio.Task.prototype.return_error_if_cancelled">Gio.Task.prototype.return_error_if_cancelled</a></li>
<li class="links "><a href="Gio.Task.return_int.html" title="Gio.Task.prototype.return_int">Gio.Task.prototype.return_int</a></li>
<li class="links "><a href="Gio.Task.return_pointer.html" title="Gio.Task.prototype.return_pointer">Gio.Task.prototype.return_pointer</a></li>
<li class="links "><a href="Gio.Task.set_check_cancellable.html" title="Gio.Task.prototype.set_check_cancellable">Gio.Task.prototype.set_check_cancellable</a></li>
<li class="links "><a href="Gio.Task.set_priority.html" title="Gio.Task.prototype.set_priority">Gio.Task.prototype.set_priority</a></li>
<li class="links "><a href="Gio.Task.set_return_on_cancel.html" title="Gio.Task.prototype.set_return_on_cancel">Gio.Task.prototype.set_return_on_cancel</a></li>
<li class="links "><a href="Gio.Task.set_source_tag.html" title="Gio.Task.prototype.set_source_tag">Gio.Task.prototype.set_source_tag</a></li>
<li class="links "><a href="Gio.Task.set_task_data.html" title="Gio.Task.prototype.set_task_data">Gio.Task.prototype.set_task_data</a></li>
</ul></div>
</div></div>
<div class="links topiclinks"><div class="inner">
<div class="title title-links"><h2><span class="title">Static Functions</span></h2></div>
<div class="region"><ul>
<li class="links "><a href="Gio.Task.is_valid.html" title="Gio.Task.is_valid">Gio.Task.is_valid</a></li>
<li class="links "><a href="Gio.Task.report_error.html" title="Gio.Task.report_error">Gio.Task.report_error</a></li>
</ul></div>
</div></div>
</div>
<div class="sect sect-links" role="navigation">
<div class="hgroup"></div>
<div class="contents"><div class="links guidelinks"><div class="inner">
<div class="title"><h2><span class="title">More Information</span></h2></div>
<div class="region"><ul><li class="links "><a href="index.html" title="Gio">Gio</a></li></ul></div>
</div></div></div>
</div>
</div>
<div class="clear"></div>
</div>
<div class="footer"></div>
</div></body>
</html>
