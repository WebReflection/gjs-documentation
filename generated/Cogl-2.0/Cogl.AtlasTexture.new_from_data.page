<?xml version="1.0"?>
<page id="Cogl.AtlasTexture.new_from_data"
      type="topic"
      style="constructor"
      xmlns="http://projectmallard.org/1.0/"
      xmlns:api="http://projectmallard.org/experimental/api/"
      xmlns:ui="http://projectmallard.org/1.0/ui/">
  <info>
    <link xref="Cogl.AtlasTexture" group="constructor" type="guide"/>
    <api:function>
      <api:returns>
        <api:type>Cogl.AtlasTexture</api:type>
      </api:returns>
      <api:name>cogl_atlas_texture_new_from_data</api:name>
      <api:arg>
        <api:type>Cogl.Context</api:type>
        <api:name>ctx</api:name>
      </api:arg>
      <api:arg>
        <api:type>Number(gint)</api:type>
        <api:name>width</api:name>
      </api:arg>
      <api:arg>
        <api:type>Number(gint)</api:type>
        <api:name>height</api:name>
      </api:arg>
      <api:arg>
        <api:type>Cogl.PixelFormat</api:type>
        <api:name>format</api:name>
      </api:arg>
      <api:arg>
        <api:type>Number(gint)</api:type>
        <api:name>rowstride</api:name>
      </api:arg>
      <api:arg>
        <api:type>Number(guint8)</api:type>
        <api:name>data</api:name>
      </api:arg>
    </api:function>
  </info>
  <title>Cogl.AtlasTexture.new_from_data</title>
  <synopsis><code mime="text/x-gjs">
function new_from_data(ctx: <link xref="Cogl.Context">Cogl.Context</link>, width: Number(gint), height: Number(gint), format: <link xref="Cogl.PixelFormat">Cogl.PixelFormat</link>, rowstride: Number(gint), data: Number(guint8)): <link xref="Cogl.AtlasTexture">Cogl.AtlasTexture</link> {
    // Gjs wrapper for cogl_atlas_texture_new_from_data()
}
  </code></synopsis>
  <p>Creates a new <link xref="Cogl.AtlasTexture"/> texture based on data residing in
memory. A <link xref="Cogl.AtlasTexture"/> represents a sub-region within one of
Cogl's shared texture atlases.</p>  <p>&lt;note&gt;This api will always immediately allocate GPU memory for the
texture and upload the given data so that the <code>data</code> pointer does
not need to remain valid once this function returns. This means it
is not possible to configure the texture before it is allocated. If
you do need to configure the texture before allocation (to specify
constraints on the internal format for example) then you can
instead create a <link xref="Cogl.Bitmap"/> for your data and use
<link xref="Cogl.AtlasTexture.new_from_bitmap"/> or use
<link xref="Cogl.AtlasTexture.new_with_size"/> and then upload data using
<link xref="Cogl.Texture.set_data"/>&lt;/note&gt;</p>  <p>&lt;note&gt;Allocate call can fail if Cogl considers the internal
format to be incompatible with the format of its internal
atlases.&lt;/note&gt;</p>  <p>&lt;note&gt;The returned <link xref="Cogl.AtlasTexture"/> is a high-level
meta-texture with some limitations. See the documentation for
<link xref="Cogl.MetaTexture"/> for more details.&lt;/note&gt;</p>
  <p>Since 1.16</p>
<terms>
<item>
<title><code>ctx</code></title>
  <p>A <link xref="Cogl.Context"/></p>
</item>
<item>
<title><code>width</code></title>
  <p>width of texture in pixels</p>
</item>
<item>
<title><code>height</code></title>
  <p>height of texture in pixels</p>
</item>
<item>
<title><code>format</code></title>
  <p>the <link xref="Cogl.PixelFormat"/> the buffer is stored in in RAM</p>
</item>
<item>
<title><code>rowstride</code></title>
  <p>the memory offset in bytes between the start of each
   row in <code>data</code>. A value of 0 will make Cogl automatically
   calculate <code>rowstride</code> from <code>width</code> and <code>format</code>.</p>
</item>
<item>
<title><code>data</code></title>
  <p>pointer to the memory region where the source buffer resides</p>
</item>
<item>
<title><code>Returns</code></title>
  <p>A new <link xref="Cogl.AtlasTexture"/> object or
         <code>null</code> on failure and @error will be updated.</p>
</item>
</terms>

</page>
