<?xml version="1.0"?>
<page id="Cogl.Onscreen.show"
      type="topic"
      style="method"
      xmlns="http://projectmallard.org/1.0/"
      xmlns:api="http://projectmallard.org/experimental/api/"
      xmlns:ui="http://projectmallard.org/1.0/ui/">
  <info>
    <link xref="Cogl.Onscreen" group="method" type="guide"/>
    <api:function>
      <api:returns>
        <api:type>void</api:type>
      </api:returns>
      <api:name>cogl_onscreen_show</api:name>
    </api:function>
  </info>
  <title>Cogl.Onscreen.prototype.show</title>
  <synopsis><code mime="text/x-gjs">
function show(): void {
    // Gjs wrapper for cogl_onscreen_show()
}
  </code></synopsis>
  <p>This requests to make <code>onscreen</code> visible to the user.</p>  <p>Actually the precise semantics of this function depend on the
window system currently in use, and if you don't have a
multi-windowining system this function may in-fact do nothing.</p>  <p>This function will implicitly allocate the given <code>onscreen</code>
framebuffer before showing it if it hasn't already been allocated.</p>  <p>When using the Wayland winsys calling this will set the surface to
a toplevel type which will make it appear. If the application wants
to set a different type for the surface, it can avoid calling
<link xref="Cogl.Onscreen.show"/> and set its own type directly with the Wayland
client API via <link xref="Cogl.wayland_onscreen_get_surface"/>.</p>  <p>&lt;note&gt;Since Cogl doesn't explicitly track the visibility status of
onscreen framebuffers it wont try to avoid redundant window system
requests e.g. to show an already visible window. This also means
that it's acceptable to alternatively use native APIs to show and
hide windows without confusing Cogl.&lt;/note&gt;</p>
  <p>Since 2.0</p>

</page>
