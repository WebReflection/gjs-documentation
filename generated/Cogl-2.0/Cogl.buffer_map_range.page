<?xml version="1.0"?>
<page id="Cogl.buffer_map_range"
      type="topic"
      style="function"
      xmlns="http://projectmallard.org/1.0/"
      xmlns:api="http://projectmallard.org/experimental/api/"
      xmlns:ui="http://projectmallard.org/1.0/ui/">
  <info>
    <link xref="index" group="function" type="guide"/>
    <api:function>
      <api:returns>
        <api:type>void</api:type>
      </api:returns>
      <api:name>cogl_buffer_map_range</api:name>
      <api:arg>
        <api:type>Cogl.Buffer</api:type>
        <api:name>buffer</api:name>
      </api:arg>
      <api:arg>
        <api:type>Number(gsize)</api:type>
        <api:name>offset</api:name>
      </api:arg>
      <api:arg>
        <api:type>Number(gsize)</api:type>
        <api:name>size</api:name>
      </api:arg>
      <api:arg>
        <api:type>Cogl.BufferAccess</api:type>
        <api:name>access</api:name>
      </api:arg>
      <api:arg>
        <api:type>Cogl.BufferMapHint</api:type>
        <api:name>hints</api:name>
      </api:arg>
    </api:function>
  </info>
  <title>Cogl.buffer_map_range</title>
  <synopsis><code mime="text/x-gjs">
function buffer_map_range(buffer: <link xref="Cogl.Buffer">Cogl.Buffer</link>, offset: Number(gsize), size: Number(gsize), access: <link xref="Cogl.BufferAccess">Cogl.BufferAccess</link>, hints: <link xref="Cogl.BufferMapHint">Cogl.BufferMapHint</link>): void {
    // Gjs wrapper for cogl_buffer_map_range()
}
  </code></synopsis>
  <p>Maps a sub-region of the buffer into the application's address space
for direct access.</p>  <p>It is strongly recommended that you pass
<link xref="Cogl.BufferMapHint"/>. as a hint if you are going to replace
all the buffer's data. This way if the buffer is currently being
used by the GPU then the driver won't have to stall the CPU and
wait for the hardware to finish because it can instead allocate a
new buffer to map. You can pass
<link xref="Cogl.BufferMapHint"/>._range instead if you want the
regions outside of the mapping to be retained.</p>  <p>The behaviour is undefined if you access the buffer in a way
conflicting with the <code>access</code> mask you pass. It is also an error to
release your last reference while the buffer is mapped.</p>
  <p>Since 2.0</p>
<terms>
<item>
<title><code>buffer</code></title>
  <p>a buffer object</p>
</item>
<item>
<title><code>offset</code></title>
  <p>Offset within the buffer to start the mapping</p>
</item>
<item>
<title><code>size</code></title>
  <p>The size of data to map</p>
</item>
<item>
<title><code>access</code></title>
  <p>how the mapped buffer will be used by the application</p>
</item>
<item>
<title><code>hints</code></title>
  <p>A mask of <link xref="Cogl.BufferMapHint"/>&lt;!-- --&gt;s that tell Cogl how
  the data will be modified once mapped.</p>
</item>
<item>
<title><code>Returns</code></title>
  <p>A pointer to the mapped memory or
       <code>null</code> is the call fails</p>
</item>
</terms>

</page>
