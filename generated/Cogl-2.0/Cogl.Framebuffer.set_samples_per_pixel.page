<?xml version="1.0"?>
<page id="Cogl.Framebuffer.set_samples_per_pixel"
      type="topic"
      style="method"
      xmlns="http://projectmallard.org/1.0/"
      xmlns:api="http://projectmallard.org/experimental/api/"
      xmlns:ui="http://projectmallard.org/1.0/ui/">
  <info>
    <link xref="Cogl.Framebuffer" group="method" type="guide"/>
    <api:function>
      <api:returns>
        <api:type>void</api:type>
      </api:returns>
      <api:name>cogl_framebuffer_set_samples_per_pixel</api:name>
      <api:arg>
        <api:type>Number(gint)</api:type>
        <api:name>samples_per_pixel</api:name>
      </api:arg>
    </api:function>
  </info>
  <title>Cogl.Framebuffer.prototype.set_samples_per_pixel</title>
  <synopsis><code mime="text/x-gjs">
function set_samples_per_pixel(samples_per_pixel: Number(gint)): void {
    // Gjs wrapper for cogl_framebuffer_set_samples_per_pixel()
}
  </code></synopsis>
  <p>Requires that when rendering to <code>framebuffer</code> then @n point samples
should be made per pixel which will all contribute to the final
resolved color for that pixel. The idea is that the hardware aims
to get quality similar to what you would get if you rendered
everything twice as big (for 4 samples per pixel) and then scaled
that image back down with filtering. It can effectively remove the
jagged edges of polygons and should be more efficient than if you
were to manually render at a higher resolution and downscale
because the hardware is often able to take some shortcuts. For
example the GPU may only calculate a single texture sample for all
points of a single pixel, and for tile based architectures all the
extra sample data (such as depth and stencil samples) may be
handled on-chip and so avoid increased demand on system memory
bandwidth.</p>  <p>By default this value is usually set to 0 and that is referred to
as "single-sample" rendering. A value of 1 or greater is referred
to as "multisample" rendering.</p>  <p>&lt;note&gt;There are some semantic differences between single-sample
rendering and multisampling with just 1 point sample such as it
being redundant to use the <link xref="Cogl.Framebuffer.resolve_samples"/> and
<link xref="Cogl.Framebuffer.resolve_samples_region"/> apis with single-sample
rendering.&lt;/note&gt;</p>  <p>&lt;note&gt;It's recommended that
<link xref="Cogl.Framebuffer.resolve_samples_region"/> be explicitly used at the
end of rendering to a point sample buffer to minimize the number of
samples that get resolved. By default Cogl will implicitly resolve
all framebuffer samples but if only a small region of a
framebuffer has changed this can lead to redundant work being
done.&lt;/note&gt;</p>
  <p>Since 1.8</p>
<terms>
<item>
<title><code>samples_per_pixel</code></title>
  <p>The minimum number of samples per pixel</p>
</item>
</terms>

</page>
