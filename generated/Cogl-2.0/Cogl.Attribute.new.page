<?xml version="1.0"?>
<page id="Cogl.Attribute.new"
      type="topic"
      style="constructor"
      xmlns="http://projectmallard.org/1.0/"
      xmlns:api="http://projectmallard.org/experimental/api/"
      xmlns:ui="http://projectmallard.org/1.0/ui/">
  <info>
    <link xref="Cogl.Attribute" group="constructor" type="guide"/>
    <api:function>
      <api:returns>
        <api:type>Cogl.Attribute</api:type>
      </api:returns>
      <api:name>cogl_attribute_new</api:name>
      <api:arg>
        <api:type>Cogl.AttributeBuffer</api:type>
        <api:name>attribute_buffer</api:name>
      </api:arg>
      <api:arg>
        <api:type>String</api:type>
        <api:name>name</api:name>
      </api:arg>
      <api:arg>
        <api:type>Number(gsize)</api:type>
        <api:name>stride</api:name>
      </api:arg>
      <api:arg>
        <api:type>Number(gsize)</api:type>
        <api:name>offset</api:name>
      </api:arg>
      <api:arg>
        <api:type>Number(gint)</api:type>
        <api:name>components</api:name>
      </api:arg>
      <api:arg>
        <api:type>Cogl.AttributeType</api:type>
        <api:name>type</api:name>
      </api:arg>
    </api:function>
  </info>
  <title>Cogl.Attribute.new</title>
  <synopsis><code mime="text/x-gjs">
function new(attribute_buffer: <link xref="Cogl.AttributeBuffer">Cogl.AttributeBuffer</link>, name: String, stride: Number(gsize), offset: Number(gsize), components: Number(gint), type: <link xref="Cogl.AttributeType">Cogl.AttributeType</link>): <link xref="Cogl.Attribute">Cogl.Attribute</link> {
    // Gjs wrapper for cogl_attribute_new()
}
  </code></synopsis>
  <p>Describes the layout for a list of vertex attribute values (For
example, a list of texture coordinates or colors).</p>  <p>The <code>name</code> is used to access the attribute inside a GLSL vertex
shader and there are some special names you should use if they are
applicable:
 &lt;itemizedlist&gt;
   &lt;listitem&gt;"cogl_position_in" (used for vertex positions)&lt;/listitem&gt;
   &lt;listitem&gt;"cogl_color_in" (used for vertex colors)&lt;/listitem&gt;
   &lt;listitem&gt;"cogl_tex_coord0_in", "cogl_tex_coord1", ...
(used for vertex texture coordinates)&lt;/listitem&gt;
   &lt;listitem&gt;"cogl_normal_in" (used for vertex normals)&lt;/listitem&gt;
   &lt;listitem&gt;"cogl_point_size_in" (used to set the size of points
   per-vertex. Note this can only be used if
   %COGL_FEATURE_ID_POINT_SIZE_ATTRIBUTE is advertised and
   <link xref="Cogl.Pipeline.set_per_vertex_point_size"/> is called on the pipeline.
   &lt;/listitem&gt;
 &lt;/itemizedlist&gt;</p>  <p>The attribute values corresponding to different vertices can either
be tightly packed or interleaved with other attribute values. For
example it's common to define a structure for a single vertex like:
|[
typedef struct
{
  float x, y, z; /&lt;!-- --&gt;* position attribute *&lt;!-- --&gt;/
  float s, t; /&lt;!-- --&gt;* texture coordinate attribute *&lt;!-- --&gt;/
} MyVertex;
]|</p>  <p>And then create an array of vertex data something like:
|[
MyVertex vertices[100] = { .... }
]|</p>  <p>In this case, to describe either the position or texture coordinate
attribute you have to move &lt;literal&gt;sizeof (MyVertex)&lt;/literal&gt; bytes to
move from one vertex to the next.  This is called the attribute
<code>stride</code>. If you weren't interleving attributes and you instead had
a packed array of float x, y pairs then the attribute stride would
be &lt;literal&gt;(2 * sizeof (float))&lt;/literal&gt;. So the <code>stride</code> is the number of
bytes to move to find the attribute value of the next vertex.</p>  <p>Normally a list of attributes starts at the beginning of an array.
So for the &lt;literal&gt;MyVertex&lt;/literal&gt; example above the <code>offset</code> is the
offset inside the &lt;literal&gt;MyVertex&lt;/literal&gt; structure to the first
component of the attribute. For the texture coordinate attribute
the offset would be &lt;literal&gt;offsetof (MyVertex, s)&lt;/literal&gt; or instead of
using the offsetof macro you could use &lt;literal&gt;sizeof (float) *
3&lt;/literal&gt;.  If you've divided your @array into blocks of non-interleved
attributes then you will need to calculate the <code>offset</code> as the number of
bytes in blocks preceding the attribute you're describing.</p>  <p>An attribute often has more than one component. For example a color
is often comprised of 4 red, green, blue and alpha <code>components</code>, and a
position may be comprised of 2 x and y <code>components</code>. You should aim
to keep the number of components to a minimum as more components
means more data needs to be mapped into the GPU which can be a
bottlneck when dealing with a large number of vertices.</p>  <p>Finally you need to specify the component data type. Here you
should aim to use the smallest type that meets your precision
requirements. Again the larger the type then more data needs to be
mapped into the GPU which can be a bottlneck when dealing with
a large number of vertices.</p>
  <p>Since 1.4</p>
<terms>
<item>
<title><code>attribute_buffer</code></title>
  <p>The <link xref="Cogl.AttributeBuffer"/> containing the actual
                   attribute data</p>
</item>
<item>
<title><code>name</code></title>
  <p>The name of the attribute (used to reference it from GLSL)</p>
</item>
<item>
<title><code>stride</code></title>
  <p>The number of bytes to jump to get to the next attribute
         value for the next vertex. (Usually
         &lt;literal&gt;sizeof (MyVertex)&lt;/literal&gt;)</p>
</item>
<item>
<title><code>offset</code></title>
  <p>The byte offset from the start of <code>attribute_buffer</code> for
         the first attribute value. (Usually
         &lt;literal&gt;offsetof (MyVertex, component0)&lt;/literal&gt;</p>
</item>
<item>
<title><code>components</code></title>
  <p>The number of components (e.g. 4 for an rgba color or
             3 for and (x,y,z) position)</p>
</item>
<item>
<title><code>type</code></title>
  <p>FIXME</p>
</item>
<item>
<title><code>Returns</code></title>
  <p>A newly allocated <link xref="Cogl.Attribute"/>
         describing the layout for a list of attribute values
         stored in @array.</p>
</item>
</terms>

</page>
