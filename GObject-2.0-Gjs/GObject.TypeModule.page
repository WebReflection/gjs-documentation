<?xml version="1.0"?>
<page id="GObject.TypeModule"
      type="guide"
      style="class"
      xmlns="http://projectmallard.org/1.0/"
      xmlns:api="http://projectmallard.org/experimental/api/"
      xmlns:ui="http://projectmallard.org/1.0/ui/">
  <info>
    <link xref="index" group="class" type="guide"/>
  </info>
  <title>GObject.TypeModule</title>
  <synopsis><code>
const GObject = imports.gi.GObject;

let typeModule = new GObject.TypeModule();
  </code></synopsis>
  <p><link xref="GObject.TypeModule"/> provides a simple implementation of the <link xref="GObject.TypePlugin"/>
interface. The model of <link xref="GObject.TypeModule"/> is a dynamically loaded module
which implements some number of types and interface implementations.
When the module is loaded, it registers its types and interfaces
using <link xref="GObject.TypeModule.register_type"/> and <link xref="GObject.TypeModule.add_interface"/>.
As long as any instances of these types and interface implementations
are in use, the module is kept loaded. When the types and interfaces
are gone, the module may be unloaded. If the types and interfaces
become used again, the module will be reloaded. Note that the last
unref cannot happen in module code, since that would lead to the
caller's code being unloaded before <link xref="GObject.Object.unref"/> returns to it.</p>  <p>Keeping track of whether the module should be loaded or not is done by
using a use count - it starts at zero, and whenever it is greater than
zero, the module is loaded. The use count is maintained internally by
the type system, but also can be explicitly controlled by
<link xref="GObject.TypeModule.use"/> and <link xref="GObject.TypeModule.unuse"/>. Typically, when loading
a module for the first type, <link xref="GObject.TypeModule.use"/> will be used to load
it so that it can initialize its types. At some later point, when the
module no longer needs to be loaded except for the type
implementations it contains, <link xref="GObject.TypeModule.unuse"/> is called.</p>  <p><link xref="GObject.TypeModule"/> does not actually provide any implementation of module
loading and unloading. To create a particular module type you must
derive from <link xref="GObject.TypeModule"/> and implement the load and unload functions
in <link xref="GObject.TypeModuleClass"/>.</p>

  <synopsis>
    <title>Hierarchy</title>
    <tree>
      <item>
        <code>GObject.Object</code>
      <item>
        <code>GObject.TypeModule</code>
      </item>
      </item>
    </tree>
  </synopsis>
  <links type="topic" ui:expanded="true"
         api:type="function" api:mime="text/x-gjs"
         groups="constructor" style="linklist">
    <title>Constructors</title>
  </links>
  <links type="topic" ui:expanded="true"
         api:type="function" api:mime="text/x-gjs"
         groups="method" style="linklist">
    <title>Methods</title>
  </links>
  <links type="topic" ui:expanded="true"
         api:type="function" api:mime="text/x-gjs"
         groups="function" style="linklist">
    <title>Static Functions</title>
  </links>
  <links type="topic" ui:expanded="true" groups="property" style="linklist">
    <title>Properties</title>
  </links>
  <links type="topic" ui:expanded="true" groups="signal" style="linklist">
    <title>Signals</title>
  </links>
  <links type="topic" ui:expanded="true" groups="vfunc" style="linklist">
    <title>Virtual functions</title>
  </links>
  <links type="topic" ui:expanded="true" groups="field" style="linklist">
    <title>Fields</title>
  </links>
  <links type="topic" ui:expanded="true" groups="#first #default #last" style="linklist">
    <title>Other</title>
  </links>
</page>
