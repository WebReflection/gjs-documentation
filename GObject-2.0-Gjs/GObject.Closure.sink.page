<?xml version="1.0"?>
<page id="GObject.Closure.sink"
      type="topic"
      style="method"
      xmlns="http://projectmallard.org/1.0/"
      xmlns:api="http://projectmallard.org/experimental/api/"
      xmlns:ui="http://projectmallard.org/1.0/ui/">
  <info>
    <link xref="GObject.Closure" group="method" type="guide"/>
    <api:function>
      <api:returns>
        <api:type>void</api:type>
      </api:returns>
      <api:name>g_closure_sink</api:name>
    </api:function>
  </info>
  <title>GObject.Closure.prototype.sink</title>
  <synopsis><code mime="text/x-gjs">
function sink(): void {
    // Gjs wrapper for g_closure_sink()
}
  </code></synopsis>
  <p>Takes over the initial ownership of a closure.  Each closure is
initially created in a "floating" state, which means that the initial
reference count is not owned by any caller. <link xref="GObject.Closure.sink"/> checks
to see if the object is still floating, and if so, unsets the
floating state and decreases the reference count. If the closure
is not floating, <link xref="GObject.Closure.sink"/> does nothing. The reason for the
existence of the floating state is to prevent cumbersome code
sequences like:
|[&lt;!-- language="C" --&gt;
closure = g_cclosure_new (cb_func, cb_data);
g_source_set_closure (source, closure);
g_closure_unref (closure); // GObject doesn't really need this
]|
Because <link xref="GObject.source_set_closure"/> (and similar functions) take ownership of the
initial reference count, if it is unowned, we instead can write:
|[&lt;!-- language="C" --&gt;
g_source_set_closure (source, g_cclosure_new (cb_func, cb_data));
]|</p>  <p>Generally, this function is used together with <link xref="GObject.Closure.ref"/>. Ane example
of storing a closure for later notification looks like:
|[&lt;!-- language="C" --&gt;
static GClosure *notify_closure = NULL;
void
foo_notify_set_closure (GClosure *closure)
{
  if (notify_closure)
    g_closure_unref (notify_closure);
  notify_closure = closure;
  if (notify_closure)
    {
      g_closure_ref (notify_closure);
      g_closure_sink (notify_closure);
    }
}
]|</p>  <p>Because <link xref="GObject.Closure.sink"/> may decrement the reference count of a closure
(if it hasn't been called on <code>closure</code> yet) just like <link xref="GObject.unref"/>,
<link xref="GObject.Closure.ref"/> should be called prior to this function.</p>


</page>
